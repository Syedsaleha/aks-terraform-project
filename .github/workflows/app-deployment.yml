name: Application Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        type: choice
        options:
          - dev
          - stage
          - prod
      frontend_image_tag:
        description: 'Frontend Docker image tag'
        required: false
        default: 'latest'
      backend_image_tag:
        description: 'Backend Docker image tag'
        required: false
        default: 'latest'
      app_repository:
        description: 'Remote GitHub repo for app (owner/repo)'
        required: false
        default: 'pravinmishraaws/book-review-app'
      app_branch:
        description: 'Branch of the app repository'
        required: false
        default: 'main'
      run_id:
        description: 'Infra workflow run ID (for fetching Terraform state)'
        required: false

permissions:
  contents: read
  id-token: write

env:
  FRONTEND_PATH: './frontend'   # root folder Dockerfile
  BACKEND_PATH: './backend'     # root folder Dockerfile
  K8S_PATH: './k8s'

jobs:

  build-and-push-images:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    outputs:
      acr-login-server: ${{ steps.get-infra.outputs.acr-login-server }}
      aks-cluster-name: ${{ steps.get-infra.outputs.aks-cluster-name }}
      resource-group: ${{ steps.get-infra.outputs.resource-group }}
      mysql-fqdn: ${{ steps.get-infra.outputs.mysql-fqdn }}
      frontend-image: ${{ steps.get-infra.outputs.acr-login-server }}/book-review-frontend:${{ github.event.inputs.frontend_image_tag }}
      backend-image: ${{ steps.get-infra.outputs.acr-login-server }}/book-review-backend:${{ github.event.inputs.backend_image_tag }}

    steps:

      - name: Checkout Infra Repository
        uses: actions/checkout@v4

      - name: Download Terraform State
        uses: actions/download-artifact@v4
        with:
          name: terraform-state-${{ github.event.inputs.environment }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ github.event.inputs.run_id }}
          repository: ${{ github.repository }}

      - name: Fetch Remote Application Repo
        run: |
          APP_REPO="${{ github.event.inputs.app_repository }}"
          APP_BRANCH="${{ github.event.inputs.app_branch }}"
          git clone --branch $APP_BRANCH --depth 1 https://github.com/$APP_REPO.git app
          echo "‚úÖ App repo fetched"

      - name: Extract Terraform Outputs
        id: get-infra
        run: |
          ACR_NAME=$(jq -r '.acr_name.value' terraform-outputs.json)
          ACR_LOGIN_SERVER=$(jq -r '.acr_login_server.value' terraform-outputs.json)
          AKS_CLUSTER_NAME=$(jq -r '.aks_cluster_name.value' terraform-outputs.json)
          RESOURCE_GROUP=$(jq -r '.resource_group_name.value' terraform-outputs.json)
          MYSQL_FQDN=$(jq -r '.mysql_fqdn.value' terraform-outputs.json)
          
          echo "acr-name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "acr-login-server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          echo "aks-cluster-name=$AKS_CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "resource-group=$RESOURCE_GROUP" >> $GITHUB_OUTPUT
          echo "mysql-fqdn=$MYSQL_FQDN" >> $GITHUB_OUTPUT

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        run: az acr login --name ${{ steps.get-infra.outputs.acr-name }}

      - name: Build & Push Backend Image
        run: |
          docker build -t ${{ steps.get-infra.outputs.acr-login-server }}/book-review-backend:${{ github.event.inputs.backend_image_tag }} \
            -f ./docker/backend.Dockerfile ./app
          docker push ${{ steps.get-infra.outputs.acr-login-server }}/book-review-backend:${{ github.event.inputs.backend_image_tag }}

      - name: Build & Push Frontend Image
        run: |
          docker build -t ${{ steps.get-infra.outputs.acr-login-server }}/book-review-frontend:${{ github.event.inputs.frontend_image_tag }} \
            -f ./docker/frontend.Dockerfile ./app
          docker push ${{ steps.get-infra.outputs.acr-login-server }}/book-review-frontend:${{ github.event.inputs.frontend_image_tag }}

  deploy-to-aks:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    needs: build-and-push-images
    environment: ${{ github.event.inputs.environment }}
    steps:

      - name: Checkout Infra Repo
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Assign AKS Cluster Admin Role
        run: |
          echo "üîê Ensuring service principal has AKS admin access..."
          
          # Get the service principal object ID
          SP_OBJECT_ID=$(az ad sp show --id ${{ secrets.AZURE_CLIENT_ID }} --query id -o tsv)
          
          # Get AKS resource ID
          AKS_ID=$(az aks show \
            --resource-group ${{ needs.build-and-push-images.outputs.resource-group }} \
            --name ${{ needs.build-and-push-images.outputs.aks-cluster-name }} \
            --query id -o tsv)
          
          # Assign Azure Kubernetes Service Cluster Admin Role
          az role assignment create \
            --assignee $SP_OBJECT_ID \
            --role "Azure Kubernetes Service Cluster Admin Role" \
            --scope $AKS_ID \
            2>/dev/null || echo "Role assignment already exists or not needed"
          
          echo "‚úÖ Role assignment complete"

      - name: Get AKS Credentials
        run: |
          echo "‚úÖ Using infrastructure details from Terraform:"
          echo "  AKS: ${{ needs.build-and-push-images.outputs.aks-cluster-name }}"
          echo "  Resource Group: ${{ needs.build-and-push-images.outputs.resource-group }}"
          
          # Get AKS credentials with admin access (uses cluster certificates)
          # This bypasses Azure RBAC and works with service principal authentication
          az aks get-credentials \
            --resource-group ${{ needs.build-and-push-images.outputs.resource-group }} \
            --name ${{ needs.build-and-push-images.outputs.aks-cluster-name }} \
            --admin \
            --overwrite-existing
          
          echo "‚úÖ AKS credentials configured successfully with admin access"

      - name: Set MySQL FQDN
        id: get-mysql
        run: |
          MYSQL_FQDN="${{ needs.build-and-push-images.outputs.mysql-fqdn }}"
          echo "mysql-fqdn=$MYSQL_FQDN" >> $GITHUB_OUTPUT
          echo "‚úÖ MySQL FQDN from Terraform: $MYSQL_FQDN"
      
      - name: Update Kubernetes Manifests
        run: |
          # Extract ACR name from login server
          ACR_NAME=$(echo "${{ needs.build-and-push-images.outputs.acr-login-server }}" | cut -d'.' -f1)
          MYSQL_FQDN="${{ steps.get-mysql.outputs.mysql-fqdn }}"
          
          echo "üîÑ Updating manifests with actual values..."
          echo "  ACR: $ACR_NAME"
          echo "  MySQL FQDN: $MYSQL_FQDN"
          
          if [ -z "$MYSQL_FQDN" ] || [ "$MYSQL_FQDN" == "null" ]; then
            echo "‚ùå ERROR: MYSQL_FQDN is empty or null!"
            exit 1
          fi
          
          # Update backend deployment
          sed -i "s|<ACR_NAME>\.azurecr\.io/book-review-backend:latest|${{ needs.build-and-push-images.outputs.backend-image }}|g" \
            ${{ env.K8S_PATH }}/deployments/backend-deployment.yaml
          
          # Update frontend deployment  
          sed -i "s|<ACR_NAME>\.azurecr\.io/book-review-frontend:latest|${{ needs.build-and-push-images.outputs.frontend-image }}|g" \
            ${{ env.K8S_PATH }}/deployments/frontend-deployment.yaml
          
          # Update ConfigMap with MySQL FQDN - use explicit string
          sed -i "s|database_host: \"<MYSQL_FQDN>\"|database_host: \"$MYSQL_FQDN\"|g" \
            ${{ env.K8S_PATH }}/configmaps/app-config.yaml
          
          # Verify replacements
          echo ""
          echo "üìã Verification - ConfigMap database_host:"
          grep "database_host:" ${{ env.K8S_PATH }}/configmaps/app-config.yaml
          
          echo ""
          echo "üìã Verification - Backend image:"
          grep "image:" ${{ env.K8S_PATH }}/deployments/backend-deployment.yaml | head -1
          
          # Check if placeholder still exists
          if grep -q "<MYSQL_FQDN>" ${{ env.K8S_PATH }}/configmaps/app-config.yaml; then
            echo "‚ùå ERROR: MYSQL_FQDN placeholder not replaced!"
            cat ${{ env.K8S_PATH }}/configmaps/app-config.yaml
            exit 1
          fi
          
          echo "‚úÖ Kubernetes manifests updated successfully"

      - name: Create Namespace
        run: |
          kubectl create namespace book-review-${{ github.event.inputs.environment }} --dry-run=client -o yaml | kubectl apply -f -
          kubectl config set-context --current --namespace=book-review-${{ github.event.inputs.environment }}

      - name: Create Secrets
        run: |
          kubectl create secret generic book-review-secrets \
            --from-literal=database_user=${{ secrets.MYSQL_ADMIN_USERNAME }} \
            --from-literal=database_password=${{ secrets.MYSQL_ADMIN_PASSWORD }} \
            --from-literal=jwt_secret=${{ secrets.JWT_SECRET }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy ConfigMap
        run: kubectl apply -f ${{ env.K8S_PATH }}/configmaps/app-config.yaml

      - name: Deploy Backend
        run: |
           kubectl apply -n -n book-review-${{ github.event.inputs.environment }} \
           -f ${{ env.K8S_PATH }}/deployments/backend-deployment.yaml \
           -f ${{ env.K8S_PATH }}/services/backend-service.yaml

           # Force restart to pull latest image (in case tag hasn't changed)
           echo "üîÑ Forcing rollout restart to ensure latest image is used..." 
           kubectl rollout restart deployment/book-review-backend -n book-review-${{ github.event.inputs.environment }}

           
           echo "‚è≥ Waiting for backend deployment to roll out..."
           kubectl rollout status deployment/book-review-backend -n book-review-${{ github.event.inputs.environment }} --timeout=300s || echo "‚ö†Ô∏è Rollout timeout - check debug output"
          
           echo ""
           echo "üìä Current backend pod status:"
           kubectl get pods -l component=backend -n book-review-${{ github.event.inputs.environment }}
           echo "‚úÖ Backend deployment applied"
          
      
      - name: Debug Backend Deployment
        if: always()
        continue-on-error: true
        run: |
          set +e  # Don't exit on error
          
          echo "üîç Backend Pod Status:"
          kubectl get pods -l component=backend -o wide 2>/dev/null || echo "No backend pods found"
          
          echo ""
          echo "üìã Backend Deployment Status:"
          kubectl get deployment book-review-backend 2>/dev/null || echo "Deployment not found"
          
          echo ""
          echo "üìã Backend ReplicaSet Status:"
          kubectl get rs -l app=book-review,component=backend 2>/dev/null || echo "No ReplicaSets found"
          
          echo ""
          echo "üìã Recent Events (all):"
          kubectl get events --sort-by='.lastTimestamp' 2>/dev/null | tail -20 || echo "No events found"
          
          echo ""
          echo "üìú Backend Pod Logs (if any exist):"
          PODS=$(kubectl get pod -l component=backend -o jsonpath='{.items[*].metadata.name}' 2>/dev/null)
          if [ -n "$PODS" ]; then
            for POD in $(echo $PODS | tr ' ' '\n' | head -3); do
              echo ""
              echo "=== Logs from $POD ==="
              kubectl logs $POD --tail=50 2>/dev/null || echo "Failed to get logs from $POD"
            done
          else
            echo "No backend pods available for logs"
          fi
          
          echo ""
          echo "üìã ConfigMap Values:"
          kubectl get configmap book-review-config -o yaml 2>/dev/null | grep -A 5 "data:" || echo "ConfigMap not found"
          
          exit 0  # Always succeed

      - name: Deploy Frontend
        run: |
          kubectl apply -f ${{ env.K8S_PATH }}/deployments/frontend-deployment.yaml
          kubectl apply -f ${{ env.K8S_PATH }}/services/frontend-service.yaml
          kubectl rollout restart deployment/book-review-frontend
          kubectl rollout status deployment/book-review-frontend --timeout=300s

      - name: Deploy Ingress
        run: kubectl apply -f ${{ env.K8S_PATH }}/ingress.yaml
